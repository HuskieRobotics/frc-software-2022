// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.networktables.EntryListenerFlags;
import edu.wpi.first.networktables.NetworkTableEntry;

import static frc.robot.Constants.*;
import static frc.robot.Constants.FlywheelConstants.*;

import edu.wpi.first.wpilibj.command.InstantCommand;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.commands.SetFlywheelVelocityCommand;

import java.util.Map;

import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
import com.ctre.phoenix.motorcontrol.TalonFXInvertType;
import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Flywheel extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonFX leftFlywheelMotor;
    private WPI_TalonFX rightFlywheelMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private double velocitySetPoint;
    private LimelightMath limelight;

    private NetworkTableEntry velocitySetPointNT;
    private NetworkTableEntry motorPowerNT;
    private NetworkTableEntry FConstantNT;
    private NetworkTableEntry PConstantNT;
    private NetworkTableEntry IConstantNT;
    private NetworkTableEntry DConstantNT;


    /**
    *
    */
    public Flywheel() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        leftFlywheelMotor = new WPI_TalonFX(LEFT_FLYWHEELMOTOR_CANID);
        rightFlywheelMotor = new WPI_TalonFX(RIGHT_FLYWHEELMOTOR_CANID);

        this.limelight = new LimelightMath();

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUC;TORS

        
        /* Factory Default all hardware to prevent unexpected behaviour */
        rightFlywheelMotor.configFactoryDefault();
        leftFlywheelMotor.configFactoryDefault();

        /* Config sensor used for Primary PID [Velocity] */
        TalonFXConfiguration _rightConfig = new TalonFXConfiguration();

        /* Disable all motors */
        this.rightFlywheelMotor.set(TalonFXControlMode.PercentOutput, 0);
        this.leftFlywheelMotor.set(TalonFXControlMode.PercentOutput,  0);
        
        /* Set neutral modes */
        this.leftFlywheelMotor.setNeutralMode(NeutralMode.Coast);
        this.rightFlywheelMotor.setNeutralMode(NeutralMode.Coast);

        this.leftFlywheelMotor.follow(this.rightFlywheelMotor);

        /* Configure output */
        this.rightFlywheelMotor.setInverted(TalonFXInvertType.CounterClockwise);
        this.leftFlywheelMotor.setInverted(InvertType.OpposeMaster);
        

        /*
            * Talon FX does not need sensor phase set for its integrated sensor
            * This is because it will always be correct if the selected feedback device is integrated sensor (default value)
            * and the user calls getSelectedSensor* to get the sensor's position/velocity.
            * 
            * https://phoenix-documentation.readthedocs.io/en/latest/ch14_MCSensor.html#sensor-phase
            */
        // this.rightFlywheelMotor.setSensorPhase(true);

        
        /** Feedback Sensor Configuration */

		/** Distance Configs */

		/* Configure the left Talon's selected sensor as integrated sensor */
		_rightConfig.primaryPID.selectedFeedbackSensor = TalonFXFeedbackDevice.IntegratedSensor.toFeedbackDevice(); //Local Feedback Source
        
        /* FPID for velocity */
        _rightConfig.slot0.kF = GAINS_VELOCITY.kF;
        _rightConfig.slot0.kP = GAINS_VELOCITY.kP;
        _rightConfig.slot0.kI = GAINS_VELOCITY.kI;
        _rightConfig.slot0.kD = GAINS_VELOCITY.kD;
        _rightConfig.slot0.integralZone = GAINS_VELOCITY.kIzone;
        _rightConfig.slot0.closedLoopPeakOutput = GAINS_VELOCITY.kPeakOutput;

        /* Config the neutral deadband. */
		_rightConfig.neutralDeadband = 0.001;

        /**
		 * 1ms per loop.  PID loop can be slowed down if need be.
		 * For example,
		 * - if sensor updates are too slow
		 * - sensor deltas are very small per update, so derivative error never gets large enough to be useful.
		 * - sensor movement is very slow causing the derivative error to be near zero.
		 */
		int closedLoopTimeMs = 1;
		_rightConfig.slot0.closedLoopPeriod = closedLoopTimeMs;
		_rightConfig.slot1.closedLoopPeriod = closedLoopTimeMs;
		_rightConfig.slot2.closedLoopPeriod = closedLoopTimeMs;
		_rightConfig.slot3.closedLoopPeriod = closedLoopTimeMs;

        /* APPLY the config settings */
        this.rightFlywheelMotor.configAllSettings(_rightConfig);

        //rightFlywheelMotor.selectProfileSlot(SLOT_INDEX, PID_LOOP_INDEX);

        this.velocitySetPoint = 0.0;


        Shuffleboard.getTab("Shooter").addBoolean("FlywheelIsAtSetpoint", this::isAtSetpoint);
        Shuffleboard.getTab("Shooter").addNumber("FlywheelVelocity", this::getVelocity);
        Shuffleboard.getTab("Shooter").addNumber("FlywheelRightEncoderReading",
                this.rightFlywheelMotor::getSelectedSensorVelocity);
        Shuffleboard.getTab("Shooter").addNumber("FlywheelLeftEncoderReading",
                this.leftFlywheelMotor::getSelectedSensorVelocity);
        Shuffleboard.getTab("Shooter").addNumber("FlywheelRightClosedLoopError",
                this.rightFlywheelMotor::getClosedLoopError);

        Shuffleboard.getTab("Shooter").add("Wall Shot", new SetFlywheelVelocityCommand(this, WALL_SHOT_VELOCITY));
        Shuffleboard.getTab("Shooter").add("Fender Shot", new SetFlywheelVelocityCommand(this, FENDER_SHOT_VELOCITY));
        Shuffleboard.getTab("Shooter").add("Stop Flywheel", new InstantCommand(this :: stopFlywheel));

        // Shuffleboard.getTab("Shooter").add("SpinFlywheelForFenderCommand",
        // new SpinFlywheelCommand(this, FENDER_VELOCITY));
        // Shuffleboard.getTab("Shooter").add("StopFlywheelCommand", new
        // InstantCommand(this::stopFlywheel, this));

        if(TUNING) {
            // Each robot feature that requires PID tuniing has its own Shuffleboard tab for
            // tuning (i.e., "ShooterTuning")
            // Add indicators and controls to this Shuffleboard tab to assist with
            // interactively tuning the system.

            this.velocitySetPointNT = Shuffleboard.getTab("ShooterTuning")
                    .add("VelocitySetpoint", 0.0)
                    .withWidget(BuiltInWidgets.kNumberSlider)
                    .withProperties(Map.of("min", 0, "max", 25000)) // specify widget properties here
                    .getEntry();
            this.velocitySetPointNT.addListener(event -> {
                    this.setVelocity(event.getEntry().getValue().getDouble());
                    }, EntryListenerFlags.kNew | EntryListenerFlags.kUpdate);

            this.motorPowerNT = Shuffleboard.getTab("ShooterTuning")
                    .add("Flywheel Power", 0.0)
                    .withWidget(BuiltInWidgets.kNumberSlider)
                    .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                    .getEntry();
            this.motorPowerNT.addListener(event -> {
                    leftFlywheelMotor.set(TalonFXControlMode.PercentOutput, event.getEntry().getValue().getDouble());
                    rightFlywheelMotor.set(TalonFXControlMode.PercentOutput, event.getEntry().getValue().getDouble());
                    }, EntryListenerFlags.kNew | EntryListenerFlags.kUpdate);

            this.FConstantNT = Shuffleboard.getTab("ShooterTuning")
                    .add("Flywheel F", 0.0)
                    .withWidget(BuiltInWidgets.kNumberSlider)
                    .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                    .getEntry();
            this.FConstantNT.addListener(event -> {
                        this.rightFlywheelMotor.config_kF(SLOT_INDEX, event.getEntry().getValue().getDouble(), TIMEOUT_MS);
                    }, EntryListenerFlags.kNew | EntryListenerFlags.kUpdate);

            this.PConstantNT = Shuffleboard.getTab("ShooterTuning")
                    .add("Flywheel P", 0.0)
                    .withWidget(BuiltInWidgets.kNumberSlider)
                    .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                    .getEntry();
            this.PConstantNT.addListener(event -> {
                        this.rightFlywheelMotor.config_kP(SLOT_INDEX, event.getEntry().getValue().getDouble(), TIMEOUT_MS);
                    }, EntryListenerFlags.kNew | EntryListenerFlags.kUpdate);

            this.IConstantNT = Shuffleboard.getTab("ShooterTuning")
                    .add("Flywheel I", 0.0)
                    .withWidget(BuiltInWidgets.kNumberSlider)
                    .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                    .getEntry();
            this.IConstantNT.addListener(event -> {
                        this.rightFlywheelMotor.config_kI(SLOT_INDEX, event.getEntry().getValue().getDouble(), TIMEOUT_MS);
                    }, EntryListenerFlags.kNew | EntryListenerFlags.kUpdate);

            this.DConstantNT = Shuffleboard.getTab("ShooterTuning")
                    .add("Flywheel D", 0.0)
                    .withWidget(BuiltInWidgets.kNumberSlider)
                    .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                    .getEntry();
            this.DConstantNT.addListener(event -> {
                        this.rightFlywheelMotor.config_kD(SLOT_INDEX, event.getEntry().getValue().getDouble(), TIMEOUT_MS);
                    }, EntryListenerFlags.kNew | EntryListenerFlags.kUpdate);
        }
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public double getVelocity() {
        return this.rightFlywheelMotor.getSelectedSensorVelocity(SLOT_INDEX);
    }

    public void setVelocity(double velocitySetPoint) {
        this.velocitySetPoint = velocitySetPoint;
        
        rightFlywheelMotor.set(TalonFXControlMode.Velocity, velocitySetPoint);
    }

    public boolean isAtSetpoint() {
        return Math.abs(this.getVelocity() - this.velocitySetPoint) < VELOCITY_TOLERANCE;
    }

    public void stopFlywheel() {
        leftFlywheelMotor.set(TalonFXControlMode.PercentOutput, 0.0);
        rightFlywheelMotor.set(TalonFXControlMode.PercentOutput, 0.0);
    }

    public double getIdealLimelight() {
        return limelight.getIdealVelocity();
    }
}
