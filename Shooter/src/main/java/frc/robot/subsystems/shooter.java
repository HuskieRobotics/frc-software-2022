// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

//note, more specific information avaliable in masterTestBoard2022 repository under:
//shooterPID

package frc.robot.subsystems;


import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
//import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.commands.*;

import java.util.HashMap;
import java.util.Map;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;


// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class shooter extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonFX flywheelRight;
    private WPI_TalonFX flywheelLeft;
    private WPI_TalonSRX hood;
    private double hoodEncodervalue;
    private Map<Double, Double> shooterVeloLookUp; 
    private Map<Double, Double> hoodAngleLookUp; 

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

private NetworkTableEntry velocitySetPointNT;
private NetworkTableEntry powerSetPointNT;
private NetworkTableEntry rightEncoderReadingNT;
private NetworkTableEntry leftEncoderReadingNT;
private NetworkTableEntry rightClosedLoopErrorNT;
private NetworkTableEntry leftClosedLoopErrorNT;

    
    /**
    *
    */
    public shooter() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        flywheelRight = new WPI_TalonFX(Constants.ShooterConstants.rightMotorID);
 
 

        flywheelLeft = new WPI_TalonFX(Constants.ShooterConstants.leftMotorID);
        flywheelLeft.setInverted(true);//TEST THIS BEFORE RUNNING ANYTHING!!!!
        
        
        hood = new WPI_TalonSRX(Constants.ShooterConstants.hoodMotorID);
        this.shooterVeloLookUp =  new HashMap<>();
        this.hoodAngleLookUp = new HashMap<>();
        
    
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        /* Factory Default all hardware to prevent unexpected behaviour */
		flywheelRight.configFactoryDefault();
        flywheelLeft.configFactoryDefault();
		
		/* Config neutral deadband to be the smallest possible */
		flywheelRight.configNeutralDeadband(0.001);
        flywheelLeft.configNeutralDeadband(0.001);

		/* Config sensor used for Primary PID [Velocity] */
        flywheelRight.configSelectedFeedbackSensor(TalonFXFeedbackDevice.IntegratedSensor,
                                            Constants.kPIDLoopIdx, 
											Constants.kTimeoutMs);
        flywheelLeft.configSelectedFeedbackSensor(TalonFXFeedbackDevice.IntegratedSensor,
                                            Constants.kPIDLoopIdx, 
											Constants.kTimeoutMs);

		/* Config the peak and nominal outputs */
		flywheelRight.configNominalOutputForward(0, Constants.kTimeoutMs);
		flywheelRight.configNominalOutputReverse(0, Constants.kTimeoutMs);
		flywheelRight.configPeakOutputForward(1, Constants.kTimeoutMs);
		flywheelRight.configPeakOutputReverse(-1, Constants.kTimeoutMs);
        flywheelLeft.configNominalOutputForward(0, Constants.kTimeoutMs);
		flywheelLeft.configNominalOutputReverse(0, Constants.kTimeoutMs);
		flywheelLeft.configPeakOutputForward(1, Constants.kTimeoutMs);
		flywheelLeft.configPeakOutputReverse(-1, Constants.kTimeoutMs);

		/* Config the Velocity closed loop gains in slot0 */
		flywheelRight.config_kF(Constants.kPIDLoopIdx, Constants.kGains_Velocit.kF, Constants.kTimeoutMs);
		flywheelRight.config_kP(Constants.kPIDLoopIdx, Constants.kGains_Velocit.kP, Constants.kTimeoutMs);
		flywheelRight.config_kI(Constants.kPIDLoopIdx, Constants.kGains_Velocit.kI, Constants.kTimeoutMs);
		flywheelRight.config_kD(Constants.kPIDLoopIdx, Constants.kGains_Velocit.kD, Constants.kTimeoutMs);
        flywheelLeft.config_kF(Constants.kPIDLoopIdx, Constants.kGains_Velocit.kF, Constants.kTimeoutMs);
		flywheelLeft.config_kP(Constants.kPIDLoopIdx, Constants.kGains_Velocit.kP, Constants.kTimeoutMs);
		flywheelLeft.config_kI(Constants.kPIDLoopIdx, Constants.kGains_Velocit.kI, Constants.kTimeoutMs);
		flywheelLeft.config_kD(Constants.kPIDLoopIdx, Constants.kGains_Velocit.kD, Constants.kTimeoutMs);
		/*
		 * Talon FX does not need sensor phase set for its integrated sensor
		 * This is because it will always be correct if the selected feedback device is integrated sensor (default value)
		 * and the user calls getSelectedSensor* to get the sensor's position/velocity.
		 * 
		 * https://phoenix-documentation.readthedocs.io/en/latest/ch14_MCSensor.html#sensor-phase
		 */
        // flywheelRight.setSensorPhase(true);

        this.velocitySetPointNT = Shuffleboard.getTab("ShooterPID")
                .add("VelocitySetpoint", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 35000)) // specify widget properties here
                .getEntry();

        this.powerSetPointNT = Shuffleboard.getTab("ShooterPID")
                .add("PowerSetpoint", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();

        this.rightEncoderReadingNT = Shuffleboard.getTab("ShooterPID")
                .add("RightEncoderReading", 0.0)
                .getEntry();
        this.leftEncoderReadingNT = Shuffleboard.getTab("ShooterPID")
                .add("LeftEncoderReading", 0.0)
                .getEntry();

        this.rightClosedLoopErrorNT = Shuffleboard.getTab("ShooterPID")
                .add("RightClosedLoopError", 0.0)
                .getEntry();
        this.leftClosedLoopErrorNT = Shuffleboard.getTab("ShooterPID")
                .add("LeftClosedLoopError", 0.0)
                .getEntry();

        

    }
    public void setFlywheelVelo(double velo) {
        //CHECK WHICH GETS INVERSED BEFORE USING
        this.flywheelLeft.set(ControlMode.Velocity, velo);
        double power = flywheelLeft.getMotorOutputPercent();
        this.flywheelRight.set(power);
    }

    public void setHoodMotorPower(double pwr){
        this.hood.set(ControlMode.PercentOutput, pwr);
    }

    public void setShootVelocityandHoodAngle(double velocity, double sensorPosition){
        this.flywheelLeft.set(ControlMode.Velocity, velocity);
        double power = flywheelLeft.getMotorOutputPercent();
        this.flywheelRight.set(power);
        //change to selected sensor
        this.hood.setSelectedSensorPosition(sensorPosition, 0, 0);
    }
    
    /*
    public SequentialCommandGroup test0 () {
        return new SequentialCommandGroup(new SetHoodtoSetPoint(this), new SetShooterVelocity(this));
    }
    */
    
    public double getHoodEncoder(){
        this.hoodEncodervalue = hood.getSelectedSensorPosition();
        return this.hoodEncodervalue;
    }
    //distance refers to ty value, velocity refers to shooter power at certain distance
    public void addShooterVeloMap(double distance, double velocity){
        shooterVeloLookUp.put(distance, velocity);
    }
    public void addHoodAngleMap(double distance, double angle){
        shooterVeloLookUp.put(distance, angle);
    }
    //distance refers to value ty reads on limelight
    //returns the velocity to set the wheel at
    public double getShooterVeloMap(double distance){
        return shooterVeloLookUp.get(distance);
    }

    public double getHoodAngleMap(double angle){
        return shooterVeloLookUp.get(angle);
    }
    
    public double getLimelightY() {
        return NetworkTableInstance.getDefault().getTable("limelight").getEntry("ty").getDouble(0);
      }

    public double getHoodSetpoint(){
        double distance = NetworkTableInstance.getDefault().getTable("limelight").getEntry("ty").getDouble(0);
        return shooterVeloLookUp.get(distance);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        
        this.rightEncoderReadingNT.setDouble(flywheelRight.getSelectedSensorVelocity(Constants.kPIDLoopIdx));
        this.leftEncoderReadingNT.setDouble(flywheelLeft.getSelectedSensorVelocity(Constants.kPIDLoopIdx));
        this.rightClosedLoopErrorNT.setDouble(flywheelRight.getClosedLoopError(Constants.kPIDLoopIdx));
        this.leftClosedLoopErrorNT.setDouble(flywheelLeft.getClosedLoopError(Constants.kPIDLoopIdx));

        	/* Velocity Closed Loop */

			/**
			 * Convert 2000 RPM to units / 100ms.
			 * 2048 Units/Rev * 2000 RPM / 600 100ms/min in either direction:
			 * velocity setpoint is in units/100ms
			 */
			//double targetVelocity_UnitsPer100ms = leftYstick * 2000.0 * 2048.0 / 600.0;
            //double targetVelocity_UnitsPer100ms = this.velocitySetPointNT.getDouble(0.0);

            //double power = this.powerSetPointNT.getDouble(0.0);

			/* 2000 RPM in either direction */
			//flywheelRight.set(TalonFXControlMode.Velocity, targetVelocity_UnitsPer100ms);
            //flywheelLeft.set(TalonFXControlMode.Velocity, targetVelocity_UnitsPer100ms);
            //power = flywheelLeft.getMotorOutputPercent();
            //flywheelRight.set(power);
            //flywheelRight.set(power);
            //flywheelLeft.set(power);

            this.rightClosedLoopErrorNT.setDouble(flywheelRight.getClosedLoopError(Constants.kPIDLoopIdx));
            this.leftClosedLoopErrorNT.setDouble(flywheelLeft.getClosedLoopError(Constants.kPIDLoopIdx));
            
        
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.


    
}