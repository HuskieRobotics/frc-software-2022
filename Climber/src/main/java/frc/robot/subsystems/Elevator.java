

// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


// import frc.robot.commands.*;
import com.ctre.phoenix.sensors.Pigeon2;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.commands.ExtendClimberToMidRungCommand;
import frc.commands.ReachToNextRungCommand;
import frc.commands.RetractClimberFullCommand;
import frc.commands.RetractClimberMinimumCommand;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
import com.ctre.phoenix.motorcontrol.TalonFXInvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.RemoteSensorSource;
import com.ctre.phoenix.motorcontrol.StatusFrame;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;

import edu.wpi.first.networktables.NetworkTableEntry;
import static frc.robot.Constants.*;
import static frc.robot.Constants.ElevatorConstants.*;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;

import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import java.util.Map;


/**
 *
 */
public class Elevator extends SubsystemBase {
    private NetworkTableEntry elevatorMotorPowerNT;
    private NetworkTableEntry positionSetPointNT;
    private NetworkTableEntry FConstantNT;
    private NetworkTableEntry PConstantNT;
    private NetworkTableEntry IConstantNT;
    private NetworkTableEntry DConstantNT;
    private NetworkTableEntry sCurveConstantNT;
    private NetworkTableEntry velocityConstantNT;
    private NetworkTableEntry accelerationConstantNT;
    private WPI_TalonFX leftElevatorMotor;
    private WPI_TalonFX rightElevatorMotor;
    private final Pigeon2 m_pigeon = new Pigeon2(PIGEON_ID);
    private double encoderPositionSetpoint;


public Elevator() {

    this.leftElevatorMotor = new WPI_TalonFX(LEFT_ELEVATOR_MOTOR_CAN_ID); 
    this.rightElevatorMotor = new WPI_TalonFX(RIGHT_ELEVATOR_MOTOR_CAN_ID); 

    /* Factory Default all hardware to prevent unexpected behaviour */
    this.rightElevatorMotor.configFactoryDefault();
    this.leftElevatorMotor.configFactoryDefault();

	/** Invert Directions for Left and Right */
	//TalonFXInvertType _leftInvert = TalonFXInvertType.CounterClockwise; //Same as invert = "false"
	TalonFXInvertType _rightInvert = TalonFXInvertType.Clockwise; //Same as invert = "true"

	/** Config Objects for motor controllers */
	TalonFXConfiguration _leftConfig = new TalonFXConfiguration();
	TalonFXConfiguration _rightConfig = new TalonFXConfiguration();
	
    /* Disable all motors */
    this.rightElevatorMotor.set(TalonFXControlMode.PercentOutput, 0);
    this.leftElevatorMotor.set(TalonFXControlMode.PercentOutput,  0);
    
    /* Set neutral modes */
    this.leftElevatorMotor.setNeutralMode(NeutralMode.Brake);
    this.rightElevatorMotor.setNeutralMode(NeutralMode.Brake);

    /* Configure output */
    this.leftElevatorMotor.setInverted(TalonFXInvertType.CounterClockwise);
    this.rightElevatorMotor.setInverted(TalonFXInvertType.Clockwise);
    /*
        * Talon FX does not need sensor phase set for its integrated sensor
        * This is because it will always be correct if the selected feedback device is integrated sensor (default value)
        * and the user calls getSelectedSensor* to get the sensor's position/velocity.
        * 
        * https://phoenix-documentation.readthedocs.io/en/latest/ch14_MCSensor.html#sensor-phase
        */
    // this.leftElevatorMotor.setSensorPhase(true);
    // this.rightElevatorMotor.setSensorPhase(true);
    
    /** Feedback Sensor Configuration */

    /** Distance Configs */

    /* Configure the left Talon's selected sensor as integrated sensor */
    _leftConfig.primaryPID.selectedFeedbackSensor = TalonFXFeedbackDevice.IntegratedSensor.toFeedbackDevice(); //Local Feedback Source

    /* Configure the Remote (Left) Talon's selected sensor as a remote sensor for the right Talon */
    _rightConfig.remoteFilter0.remoteSensorDeviceID = this.leftElevatorMotor.getDeviceID(); //Device ID of Remote Source
    _rightConfig.remoteFilter0.remoteSensorSource = RemoteSensorSource.TalonFX_SelectedSensor; //Remote Source Type
    
    /* Now that the Left sensor can be used by the primary Talon,
        * set up the Left (Aux) and Right (Primary) distance into a single
        * Robot distance as the Primary's Selected Sensor 0. */
    setRobotDistanceConfigs(_rightInvert, _rightConfig);

    /* FPID for Distance */
    _rightConfig.slot0.kF = GAINS_POSITION.kF;
    _rightConfig.slot0.kP = GAINS_POSITION.kP;
    _rightConfig.slot0.kI = GAINS_POSITION.kI;
    _rightConfig.slot0.kD = GAINS_POSITION.kD;
    _rightConfig.slot0.integralZone = GAINS_POSITION.kIzone;
    _rightConfig.slot0.closedLoopPeakOutput = GAINS_POSITION.kPeakOutput;

    /* Config the neutral deadband. */
	_leftConfig.neutralDeadband = 0.001;
	_rightConfig.neutralDeadband = 0.001;

    /**
     * 1ms per loop.  PID loop can be slowed down if need be.
     * For example,
     * - if sensor updates are too slow
     * - sensor deltas are very small per update, so derivative error never gets large enough to be useful.
     * - sensor movement is very slow causing the derivative error to be near zero.
     */
    int closedLoopTimeMs = 1;
    _rightConfig.slot0.closedLoopPeriod = closedLoopTimeMs;
    _rightConfig.slot1.closedLoopPeriod = closedLoopTimeMs;
    _rightConfig.slot2.closedLoopPeriod = closedLoopTimeMs;
    _rightConfig.slot3.closedLoopPeriod = closedLoopTimeMs;

    /* Motion Magic Configs */
    _rightConfig.motionAcceleration = ELEVATOR_ACCELERATION; //(distance units per 100 ms) per second
    _rightConfig.motionCruiseVelocity = MAX_ELEVATOR_VELOCITY; //distance units per 100 ms
    _rightConfig.motionCurveStrength = SCURVE_STRENGTH;


    /* APPLY the config settings */
    this.leftElevatorMotor.configAllSettings(_leftConfig);
    this.rightElevatorMotor.configAllSettings(_rightConfig);


    this.rightElevatorMotor.selectProfileSlot(kSlotIdx, kPIDLoopIdx);

    

    /* Set status frame periods to ensure we don't have stale data */
    this.rightElevatorMotor.setStatusFramePeriod(StatusFrame.Status_12_Feedback1, 20, kTimeoutMs);
    this.rightElevatorMotor.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 20, kTimeoutMs);
    this.leftElevatorMotor.setStatusFramePeriod(StatusFrame.Status_2_Feedback0, 5, kTimeoutMs);

     
    /* Initialize */
    this.rightElevatorMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_Targets, 10);
    this.leftElevatorMotor.getSensorCollection().setIntegratedSensorPosition(0, kTimeoutMs);
    this.rightElevatorMotor.getSensorCollection().setIntegratedSensorPosition(0, kTimeoutMs);


    
        Shuffleboard.getTab("Elevator").addNumber("Encoder Value", this :: getElevatorEncoderHeight);
        Shuffleboard.getTab("Elevator").addNumber("Pitch Value", m_pigeon :: getPitch);
        Shuffleboard.getTab("Elevator").addNumber("Closed Loop Target", this.rightElevatorMotor :: getClosedLoopTarget);
        Shuffleboard.getTab("Elevator").addNumber("Closed Loop Error", this.rightElevatorMotor :: getClosedLoopError);
        Shuffleboard.getTab("Elevator").add("Extend Climber to Mid", new ExtendClimberToMidRungCommand(this));
        Shuffleboard.getTab("Elevator").add("Reach to Next Rung", new ReachToNextRungCommand(this));
        Shuffleboard.getTab("Elevator").add("Retract Climber Full", new RetractClimberFullCommand(this));
        Shuffleboard.getTab("Elevator").add("Retract Climber Minimum", new RetractClimberMinimumCommand(this));

        this.elevatorMotorPowerNT = Shuffleboard.getTab("Elevator")
            .add("Elevator Motors", 0.0)
            .withWidget(BuiltInWidgets.kNumberSlider)
            .withProperties(Map.of("min", 0, "max", 1)) //FIX_ME figure max motor power should be 1
            .getEntry();

            
        this.positionSetPointNT = Shuffleboard.getTab("Elevator")
            .add("Position Setpoint", 0.0)
            .withWidget(BuiltInWidgets.kNumberSlider)
            .withProperties(Map.of("min", 0, "max", MAX_ELEVATOR_HEIGHT))
            .getEntry();

        this.FConstantNT = Shuffleboard.getTab("Elevator")
                .add("Flywheel F", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();

        this.PConstantNT = Shuffleboard.getTab("Elevator")
                .add("Flywheel P", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();

        this.IConstantNT = Shuffleboard.getTab("Elevator")
                .add("Flywheel I", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();

        this.DConstantNT = Shuffleboard.getTab("Elevator")
                .add("Flywheel D", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();
            
        this.sCurveConstantNT = Shuffleboard.getTab("Elevator")
                .add("Scurve Strength", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 8.0)) // specify widget properties here
                .getEntry();

        this.velocityConstantNT = Shuffleboard.getTab("Elevator")
                .add("Max Velocity", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 8000.0)) // specify widget properties here
                .getEntry();

        this.accelerationConstantNT = Shuffleboard.getTab("Elevator")
                .add("Max Acceleration", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 8000.0)) // specify widget properties here
                .getEntry();


        this.encoderPositionSetpoint = 0.0;
    }

    @Override
    public void periodic() {
    // This method will be called once per scheduler run
    if (TUNING) {
         // when tuning, we first set motor power and check the resulting velocity
         // once we have determined our feedforward constant, comment the following lines
         // and uncomment the ones to tune the PID
        double motorPower = this.elevatorMotorPowerNT.getDouble(0.0); 
        this.leftElevatorMotor.set(ControlMode.PercentOutput, motorPower);
        this.rightElevatorMotor.set(ControlMode.PercentOutput, motorPower);


            // this.rightElevatorMotor.config_kF(SLOT_INDEX, this.FConstantNT.getDouble(0.0), kTimeoutMs);
            // this.rightElevatorMotor.config_kP(SLOT_INDEX, this.PConstantNT.getDouble(0.0), kTimeoutMs);
            // this.rightElevatorMotor.config_kI(SLOT_INDEX, this.IConstantNT.getDouble(0.0), kTimeoutMs);
            // this.rightElevatorMotor.config_kD(SLOT_INDEX, this.DConstantNT.getDouble(0.0), kTimeoutMs);
            // this.rightElevatorMotor.configMotionSCurveStrength((int) this.sCurveConstantNT.getDouble(0.0), kTimeoutMs);
            // this.rightElevatorMotor.configMotionCruiseVelocity(this.velocityConstantNT.getDouble(0.0), kTimeoutMs);
            // this.rightElevatorMotor.configMotionAcceleration(this.accelerationConstantNT.getDouble(0.0), kTimeoutMs);
            // double desiredEncoderPosition = this.positionSetPointNT.getDouble(0.0);
            // this.setElevatorMotorPosition(desiredEncoderPosition);


        }
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

   

    public double getElevatorEncoderHeight(){
        return this.rightElevatorMotor.getSelectedSensorPosition();
    }


    public void setElevatorMotorPower(double power){
        this.leftElevatorMotor.set(ControlMode.PercentOutput, power);
        this.rightElevatorMotor.set(ControlMode.PercentOutput, power);
    }

    public void setElevatorMotorPosition(double desiredEncoderPosition) {
        this.encoderPositionSetpoint = desiredEncoderPosition;
        this.rightElevatorMotor.set(ControlMode.MotionMagic, desiredEncoderPosition);
        // this.rightElevatorMotor.set(TalonFXControlMode.MotionMagic, desiredEncoderPosition, DemandType.ArbitraryFeedForward, feedFwdTerm);
        this.leftElevatorMotor.follow(this.rightElevatorMotor);
    }

    public boolean atSetpoint(){
        return Math.abs(this.getElevatorEncoderHeight() - this.encoderPositionSetpoint) < ELEVATOR_POSITION_TOLERANCE;
    }

    public void disableElevator() {
        this.leftElevatorMotor.set(ControlMode.PercentOutput, 0.0);
        this.rightElevatorMotor.set(ControlMode.PercentOutput,0.0);
    }

    public boolean atPitch(){
        return Math.abs(m_pigeon.getPitch() - PITCH_SETPOINT) < PITCH_TOLERANCE;
    }

    /** 
	 * Determines if SensorSum or SensorDiff should be used 
	 * for combining left/right sensors into Robot Distance.  
	 * 
	 * Assumes Aux Position is set as Remote Sensor 0.  
	 * 
	 * configAllSettings must still be called on the primary config
	 * after this function modifies the config values. 
	 * 
	 * @param primaryInvertType Invert of the primary Talon
	 * @param primaryConfig Configuration object to fill
	 */
	 void setRobotDistanceConfigs(TalonFXInvertType primaryInvertType, TalonFXConfiguration primaryConfig){
		/**
		 * Determine if we need a Sum or Difference.
		 * 
		 * The auxiliary Talon FX will always be positive
		 * in the forward direction because it's a selected sensor
		 * over the CAN bus.
		 * 
		 * The primary's native integrated sensor may not always be positive when forward because
		 * sensor phase is only applied to *Selected Sensors*, not native
		 * sensor sources.  And we need the native to be combined with the 
		 * aux (other side's) distance into a single robot distance.
		 */

		/* THIS FUNCTION should not need to be modified. 
		   This setup will work regardless of whether the primary
		   is on the Right or Left side since it only deals with
		   distance magnitude.  */

		/* Check if we're inverted */
		if (primaryInvertType == TalonFXInvertType.Clockwise){
			/* 
				If primary is inverted, that means the integrated sensor
				will be negative in the forward direction.

				If primary is inverted, the final sum/diff result will also be inverted.
				This is how Talon FX corrects the sensor phase when inverting 
				the motor direction.  This inversion applies to the *Selected Sensor*,
				not the native value.

				Will a sensor sum or difference give us a positive total magnitude?

				Remember the primary is one side of your drivetrain distance and 
				Auxiliary is the other side's distance.

					Phase | Term 0   |   Term 1  | Result
				Sum:  -((-)Primary + (+)Aux   )| NOT OK, will cancel each other out
				Diff: -((-)Primary - (+)Aux   )| OK - This is what we want, magnitude will be correct and positive.
				Diff: -((+)Aux    - (-)Primary)| NOT OK, magnitude will be correct but negative
			*/

			primaryConfig.diff0Term = TalonFXFeedbackDevice.IntegratedSensor.toFeedbackDevice(); //Local Integrated Sensor
			primaryConfig.diff1Term = TalonFXFeedbackDevice.RemoteSensor0.toFeedbackDevice();   //Aux Selected Sensor
			primaryConfig.primaryPID.selectedFeedbackSensor = TalonFXFeedbackDevice.SensorDifference.toFeedbackDevice(); //Diff0 - Diff1
		} else {
			/* primary is not inverted, both sides are positive so we can sum them. */
			primaryConfig.sum0Term = TalonFXFeedbackDevice.RemoteSensor0.toFeedbackDevice();    //Aux Selected Sensor
			primaryConfig.sum1Term = TalonFXFeedbackDevice.IntegratedSensor.toFeedbackDevice(); //Local IntegratedSensor
			primaryConfig.primaryPID.selectedFeedbackSensor = TalonFXFeedbackDevice.SensorSum.toFeedbackDevice(); //Sum0 + Sum1
		}

		/* Since the Distance is the sum of the two sides, divide by 2 so the total isn't double
		   the real-world value */
		primaryConfig.primaryPID.selectedFeedbackCoefficient = 0.5;
	 }
}



