// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.networktables.NetworkTableEntry;
import frc.robot.Constants;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.shuffleboard.BuiltInWidgets;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj2.command.InstantCommand;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import java.util.Map;

import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.TalonFXFeedbackDevice;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Flywheel extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private WPI_TalonFX talonLeft;
    private WPI_TalonFX talonRight;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private double velocitySetPoint;

    private NetworkTableEntry isAtSetpointNT;
    private NetworkTableEntry rightEncoderReadingNT;
    private NetworkTableEntry leftEncoderReadingNT;
    private NetworkTableEntry rightClosedLoopErrorNT;
    private NetworkTableEntry leftClosedLoopErrorNT;

    private NetworkTableEntry velocitySetPointNT;
    private NetworkTableEntry motorPowerNT;
    private NetworkTableEntry FConstantNT;
    private NetworkTableEntry PConstantNT;
    private NetworkTableEntry IConstantNT;
    private NetworkTableEntry DConstantNT;

    /**
    *
    */
    public Flywheel() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        talonLeft = new WPI_TalonFX(1);

        talonRight = new WPI_TalonFX(2);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        this.talonLeft.setInverted(true);

        /* Factory Default all hardware to prevent unexpected behaviour */
        this.talonRight.configFactoryDefault();
        this.talonLeft.configFactoryDefault();

        /* Config neutral deadband to be the smallest possible */
        this.talonRight.configNeutralDeadband(0.001);
        this.talonLeft.configNeutralDeadband(0.001);

        /* Config sensor used for Primary PID [Velocity] */
        this.talonRight.configSelectedFeedbackSensor(TalonFXFeedbackDevice.IntegratedSensor,
                Constants.FLYWHEEL_SLOT_INDEX,
                Constants.FLYWHELL_TIMEOUT_MS);
        this.talonLeft.configSelectedFeedbackSensor(TalonFXFeedbackDevice.RemoteSensor0,
                Constants.FLYWHEEL_SLOT_INDEX,
                Constants.FLYWHELL_TIMEOUT_MS);

        /* Config the peak and nominal outputs */
        this.talonRight.configNominalOutputForward(0, Constants.FLYWHELL_TIMEOUT_MS);
        this.talonRight.configNominalOutputReverse(0, Constants.FLYWHELL_TIMEOUT_MS);
        this.talonRight.configPeakOutputForward(1, Constants.FLYWHELL_TIMEOUT_MS);
        this.talonRight.configPeakOutputReverse(-1, Constants.FLYWHELL_TIMEOUT_MS);
        this.talonLeft.configNominalOutputForward(0, Constants.FLYWHELL_TIMEOUT_MS);
        this.talonLeft.configNominalOutputReverse(0, Constants.FLYWHELL_TIMEOUT_MS);
        this.talonLeft.configPeakOutputForward(1, Constants.FLYWHELL_TIMEOUT_MS);
        this.talonLeft.configPeakOutputReverse(-1, Constants.FLYWHELL_TIMEOUT_MS);

        /* Config the Velocity closed loop gains in slot0 */
        this.talonRight.config_kF(Constants.FLYWHEEL_SLOT_INDEX, Constants.FLYWHEEL_VELOCITY_GAINS.kF,
                Constants.FLYWHELL_TIMEOUT_MS);
        this.talonRight.config_kP(Constants.FLYWHEEL_SLOT_INDEX, Constants.FLYWHEEL_VELOCITY_GAINS.kP,
                Constants.FLYWHELL_TIMEOUT_MS);
        this.talonRight.config_kI(Constants.FLYWHEEL_SLOT_INDEX, Constants.FLYWHEEL_VELOCITY_GAINS.kI,
                Constants.FLYWHELL_TIMEOUT_MS);
        this.talonRight.config_kD(Constants.FLYWHEEL_SLOT_INDEX, Constants.FLYWHEEL_VELOCITY_GAINS.kD,
                Constants.FLYWHELL_TIMEOUT_MS);
        this.talonLeft.config_kF(Constants.FLYWHEEL_SLOT_INDEX, Constants.FLYWHEEL_VELOCITY_GAINS.kF,
                Constants.FLYWHELL_TIMEOUT_MS);
        this.talonLeft.config_kP(Constants.FLYWHEEL_SLOT_INDEX, Constants.FLYWHEEL_VELOCITY_GAINS.kP,
                Constants.FLYWHELL_TIMEOUT_MS);
        this.talonLeft.config_kI(Constants.FLYWHEEL_SLOT_INDEX, Constants.FLYWHEEL_VELOCITY_GAINS.kI,
                Constants.FLYWHELL_TIMEOUT_MS);
        this.talonLeft.config_kD(Constants.FLYWHEEL_SLOT_INDEX, Constants.FLYWHEEL_VELOCITY_GAINS.kD,
                Constants.FLYWHELL_TIMEOUT_MS);
        /*
         * Talon FX does not need sensor phase set for its integrated sensor
         * This is because it will always be correct if the selected feedback device is
         * integrated sensor (default value)
         * and the user calls getSelectedSensor* to get the sensor's position/velocity.
         * 
         * https://phoenix-documentation.readthedocs.io/en/latest/ch14_MCSensor.html#
         * sensor-phase
         */
        // this.talonRight.setSensorPhase(true);

        this.velocitySetPoint = 0.0;

        this.isAtSetpointNT = Shuffleboard.getTab("Shooter")
                .add("FlywheelIsAtSetpoint", false)
                .getEntry();
        this.rightEncoderReadingNT = Shuffleboard.getTab("Shooter")
                .add("FlywheelRightEncoderReading", 0.0)
                .getEntry();
        this.leftEncoderReadingNT = Shuffleboard.getTab("Shooter")
                .add("FlywheelLeftEncoderReading", 0.0)
                .getEntry();

        this.rightClosedLoopErrorNT = Shuffleboard.getTab("Shooter")
                .add("FlywheelRightClosedLoopError", 0.0)
                .getEntry();
        this.leftClosedLoopErrorNT = Shuffleboard.getTab("Shooter")
                .add("FlywheelLeftClosedLoopError", 0.0)
                .getEntry();

        Shuffleboard.getTab("Shooter").add("SpinFlywheelForFenderCommand",
                new SpinFlywheelCommand(this, Constants.FLYWHEEL_FENDER_VELOCITY));
        Shuffleboard.getTab("Shooter").add("StopFlywheelCommand", new InstantCommand(this::stopFlywheel, this));

        this.velocitySetPointNT = Shuffleboard.getTab("ShooterTuning")
                .add("VelocitySetpoint", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 25000)) // specify widget properties here
                .getEntry();

        this.motorPowerNT = Shuffleboard.getTab("ShooterTuning")
                .add("Flywheel Power", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();

        this.FConstantNT = Shuffleboard.getTab("ShooterTuning")
                .add("Flywheel F", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();

        this.PConstantNT = Shuffleboard.getTab("ShooterTuning")
                .add("Flywheel P", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();

        this.IConstantNT = Shuffleboard.getTab("ShooterTuning")
                .add("Flywheel I", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();

        this.DConstantNT = Shuffleboard.getTab("ShooterTuning")
                .add("Flywheel D", 0.0)
                .withWidget(BuiltInWidgets.kNumberSlider)
                .withProperties(Map.of("min", 0, "max", 1.0)) // specify widget properties here
                .getEntry();

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        this.isAtSetpointNT.setBoolean(this.isAtSetpoint());
        this.rightEncoderReadingNT.setDouble(this.talonRight.getSelectedSensorVelocity(Constants.FLYWHEEL_SLOT_INDEX));
        this.leftEncoderReadingNT.setDouble(this.talonLeft.getSelectedSensorVelocity(Constants.FLYWHEEL_SLOT_INDEX));
        this.rightClosedLoopErrorNT.setDouble(this.talonRight.getClosedLoopError(Constants.FLYWHEEL_SLOT_INDEX));
        this.leftClosedLoopErrorNT.setDouble(this.talonLeft.getClosedLoopError(Constants.FLYWHEEL_SLOT_INDEX));

        if (Constants.TUNING) {

            // when tuning, we first set motor power and check the resulting velocity
            // once we have determined our feedforward constant, comment the following lines
            // and uncomment the ones to tune the PID
            double motorPower = this.motorPowerNT.getDouble(0.0);
            talonLeft.set(TalonFXControlMode.PercentOutput, motorPower);
            talonRight.set(TalonFXControlMode.PercentOutput, motorPower);

            // uncomment these lines after dtermining the feedforward
            this.talonRight.config_kF(Constants.HOOD_SLOT_INDEX, this.FConstantNT.getDouble(0.0),
                    Constants.HOOD_TIMEOUT_MS);
            this.talonRight.config_kP(Constants.HOOD_SLOT_INDEX, this.PConstantNT.getDouble(0.0),
                    Constants.HOOD_TIMEOUT_MS);
            this.talonRight.config_kI(Constants.HOOD_SLOT_INDEX, this.IConstantNT.getDouble(0.0),
                    Constants.HOOD_TIMEOUT_MS);
            this.talonRight.config_kD(Constants.HOOD_SLOT_INDEX, this.DConstantNT.getDouble(0.0),
                    Constants.HOOD_TIMEOUT_MS);
            this.talonLeft.config_kF(Constants.HOOD_SLOT_INDEX, this.FConstantNT.getDouble(0.0),
                    Constants.HOOD_TIMEOUT_MS);
            this.talonLeft.config_kP(Constants.HOOD_SLOT_INDEX, this.PConstantNT.getDouble(0.0),
                    Constants.HOOD_TIMEOUT_MS);
            this.talonLeft.config_kI(Constants.HOOD_SLOT_INDEX, this.IConstantNT.getDouble(0.0),
                    Constants.HOOD_TIMEOUT_MS);
            this.talonLeft.config_kD(Constants.HOOD_SLOT_INDEX, this.DConstantNT.getDouble(0.0),
                    Constants.HOOD_TIMEOUT_MS);

            double targetVelocity = this.velocitySetPointNT.getDouble(0.0);
            this.setVelocity(targetVelocity);

        }

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public double getVelocity() {
        return this.talonLeft.getSelectedSensorVelocity(Constants.FLYWHEEL_SLOT_INDEX);
    }

    public void setVelocity(double velocitySetPoint) {
        this.velocitySetPoint = velocitySetPoint;

        talonLeft.set(TalonFXControlMode.Velocity, velocitySetPoint);
        talonRight.set(TalonFXControlMode.Velocity, velocitySetPoint);
    }

    public boolean isAtSetpoint() {
        return Math.abs(this.getVelocity() - this.velocitySetPoint) < Constants.FLYWHEEL_VELOCITY_TOLERANCE;
    }

    public void stopFlywheel() {
        talonLeft.set(TalonFXControlMode.PercentOutput, 0.0);
        talonRight.set(TalonFXControlMode.PercentOutput, 0.0);
    }

}
